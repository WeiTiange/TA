# OpenGL高级功能
#深度测试 #模板测试 #混合 #面剔除 

#### 深度测试(Depth Test)
- ###### 深度缓冲
	- 深度缓冲用于储存每个片段的**深度值**， 当深度测试(Depth Testing)开启时，OpenGL会将当前渲染片段的深度值与深度缓冲里的深度值进行对比，执行深度测试，如果如果测试通过，深度缓冲的值会更新为新的深度值，如果失败则该片段会被舍弃
	- 深度缓冲又窗口系统自动创建，以16、24或32位的float的形式储存他的深度值。**大部分系统中深度缓冲的精度是24位**
	- 深度缓冲在**片段着色器以及模板测试运行之后**，在**屏幕空间**中运行的
		- 屏幕空间坐标可以在片段着色器中通过gl_FragCoord直接访问
		- gl_FragCoord的x，y分量分别为片段的屏幕空间坐标 ((0,0)为左下角)。而z分量为片段的深度值，即需要与深度测试中需要的值
	- *提前深度测试(Early Depth Testing)：现在大部分GPU都提供的硬件特性，允许深度测试在片段着色器之前运行。当使用提前深度测试时，片段着色器无法写入深度值* 
- ###### 深度测试设置
	- 深度测试默认禁用，需要通过GL_DEPTH_TEST来启用
		- <mark>glEnable(GL_DEPTH_TEST);</mark>
	- 开启深度测试后，应该在每次渲染迭代前(while循环的一开始)清除深度缓冲，否则会使用上一次渲染迭代写入的深度值与当前渲染迭代的片段的深度值进行对比
		- <mark>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</mark>
	- 执行深度测试并丢弃相应的片段，但是**不**更新深度缓冲，即使用一个只读(Read-Only)深度缓冲。禁用深度缓冲的写入只需要设置他的深度掩码(Depth Mask)为GL_FALSE即可。**只有在开启深度测试时才有效**
		- <mark>glDepthMask(GL_FALSE)</mark>
- ###### 深度测试函数
	- 深度测试的比较运算符是可配置的。可以用来控制OpenGL什么时候该通过或丢弃一个片段，什么时候该更新深度缓冲。通过glDepthFunc来设置
		- <mark>glDepthFunc(GL_LESS)</mark>
	- 默认情况下使用GL_LESS，他会丢弃深度值大于等于当前深度缓冲值的所有片段

| 函数        | 描述                                       |
| ----------- | ------------------------------------------ |
| GL_ALWAYS   | **永远**通过深度测试                           |
| GL_NEVER    | **永远不**通过深度测试                         |
| GL_LESS     | 在片段深度值**小于**缓冲的深度值时通过测试     |
| GL_EQUAL    | 在片段深度值**等于**缓冲的深度值时通过测试     |
| GL_LEQUAL   | 在片段深度值**小于等于**缓冲的深度值时通过测试 |
| GL_GREATER  | 在片段深度值**大于**缓冲的深度值时通过测试     |
| GL_NOTEQUAL | 在片段深度值**不等于**缓冲的深度值时通过测试   |
| GL_GEQUAL   | 在片段深度值**大于等于**缓冲的深度值时通过测试                                           |
*注：越小的深度值意味着离摄像机越近*

- ###### 深度值精度
	- 深度值介于0到1之间。观察空间的z值可能是视锥体的近平面和远平面之间的任何值，需要把z值变换到\[0,1]的范围之间
		- **线性**
			- ![[OpenGL_深度值线性变换.png]]
				- near、far是在投影矩阵里设置的near和far值
			- ![[OpenGL_深度值线性图.png]]
			- *实践中几乎永远不会使用，因为线性的方程使得远处的物体和近处的物体使用同样的精度，会导致在物体距离摄像机很近的时候精准度不够*
		- **非线性**
			- 非线性方程是透视矩阵默认使用的方程
			- 与1/z成正比，在z值很小的时候提供非常高的精度，而在z值很远的时候提供更少的精度
			- ![[OpenGL_深度值非线性方程.png]]
			- ![[OpenGL_深度值非线性变换.png]]
- ###### 深度值的可视化
	- 由于使用非线性方程的关系(越近的片段精度越高，越远的越低)，片段的深度值会随着距离的增加而快速增加，从而使得大部分片段的颜色都趋近于白色，只有里相机非常近的片段才会显示灰色
		- ![[OpenGL_深度值非线性方程可视化.png]]
	- 将非线性方程的深度值变换为线性的深度值可以正确的可视化深度值
		- 先将深度值从\[0,1]范围重新变换到\[-1,1]范围的标准化设备坐标(裁剪空间)
			- <mark>float z = depth \* 2.0 - 1.0;</mark>
		- 然后使用获取到的z值，应用逆变换来获取线性的深度值
			- <mark>float linearDepth = (2.0 * near * far) / (far + near - z * (far - near));</mark>
		- 最后在main函数中将变换为线性的深度值除以far以正确的可视化深度值
			- <mark>float depth = linearizeDepth(gl_FragCoord.z)/far;</mark>
- ###### 深度冲突
	- 如果两个三角形或平面离得特别近，并且是平行的，深度缓冲会没有足够的精度来决定他们俩谁应该在上面，结果就是两个三角形不断地切换前后顺序，这个现象叫**深度冲突(Z-fighting)** 。当物体在远处时更明显 (因为非线性方程在远处的精度更是低上加低)。
	- 深度冲突不能完全避免，但可以通过技巧来减轻/规避
		- 永远不要吧多个物体摆的太靠近，以至于他们的一些三角形会重叠
		- 尽可能将近平面设置的远一些 (离摄像机更远)，越远的近平面会使得视锥体内的整体深度值精度越高。但是近平面太远会导致近处的物体被裁剪掉，需要微调来找到合适的近平面距离
		- 使用更高精度的深度缓冲，代价是牺牲掉一些性能。大部分深度缓冲的精度都是24位的，但是大部分的显卡都支持32位的深度缓冲，32位精度可以极大地提高精度。

#### 模板测试(Stencil Test)
- ###### 模板缓冲
	- 片段着色器处理完一个片段后会进行模板测试(Stencil Test)。模板测试和深度测试一样，都有可能会丢弃片段，被保留下来的片段会进行深度测试。
	- 模板测试使用模板缓冲(stencil buffer)来进行测试
		- 通常模板缓冲中每个模板值(stencil value)是8位的，所以每个像素/片段一共能有256种不同的模板值
		- *每个窗口库都需要配置一个模板缓冲，GLFW自动做了这件事，但是其他的库可能不会*
	- **模板测试的步骤**
		- 启用模板缓冲的写入
		- 渲染物体，更新模板缓冲的内容
		- 禁用模板缓冲的写入
		- 渲染(其他)物体，这次根据模板缓冲中已绘制的其他物体的片段来决定是否丢弃特定的片段
- ###### 模板测试设置
	- 通过GL_STENCIL_TEST来启用模板测试。开启后所有的渲染调用都会以某种方式影响着模板缓冲
		- <mark>glEnable(GL_STENCIL_TEST)</mark>
	- 在每次渲染迭代的开始清除模板缓冲，否则将会使用上次迭代的数据
		- <mark>glClear(GL_STENCIL_BUFFER_BIT)</mark>
	- 可以通过glStencilMask来关闭模板缓冲的写入，默认情况下设置的掩码所有位都为1，不影响输出，但如果设置为0X00，则写入缓冲的所有模板值都会变成0，和深度测试中的glDepthMask(GL_FALSE)一样
		- <mark>glStencilMask(0xFF); // 每一位写入模板缓冲时都保持原样 </mark>
		- <mark>glStencilMask(0x00); // 每一位在写入模板缓冲时都会变成0（禁用写入）</mark>
			- **禁用写入不仅会禁止模板缓冲的写入，还会阻止模板缓冲清空(使glClear(GL_STENCIL_BUFFER_BIT)无效)**
		- *大部分情况下只会使用0x00或者0xFF作为模板掩码(Stencil Mask)，但是可以自定义*
- ###### 模板测试函数
	- 有两个函数可以用来配置模板测试，让我们对模板缓冲应该通过还是失败，以及他应该如何影响模板缓冲有一定的控制
		- <mark>glStencilFunc(GLenum func, GLint ref, GLuint mask)</mark>
			- func：设置模板测试函数(Stencil Test Function)。这个测试函数将会应用到已储存的模板值上和glStencilFunc函数的**ref**值上
			- ref：设置了模板测试的参考值(Reference Value)。模板缓冲的内容将会与这个值进行比较
			- mask：设置一个掩码，它将会与参考值和储存的模板值在测试比较它们之前进行与(AND)运算。初始情况下所有位都为1
		- <mark>glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)</mark>
			- sfail：模板测试失败时采取的行为
			- dpfail：模板测试通过，但深度测试失败时采取的行为
			- dppass：模板测试和深度测试都通过时采取的行为

| 模板测试函数 | 描述                                             |
| ------------ | ------------------------------------------------ |
| GL_ALWAYS    | **永远**通过模板测试                                             |
| GL_NEVER     | **永远不**通过模板测试                           |
| GL_LESS      | 在片段模板值**小于**缓冲的模板值时通过测试       |
| GL_LEQUAL    | 在片段的模板值**小于等于**缓冲的模板值时通过测试 |
| GL_GREATER   | 在片段的模板值**大于缓冲**的模板值时通过测试     |
| GL_GEQUAL    | 在片段的模板值**大于等于**缓冲的模板值时通过测试 |
| GL_EQUAL     | 在片段的模板值**等于**缓冲的模板值时通过测试     |
| GL_NOTEQUAL  | 在片段的模板值**不等于**缓冲的模板值时通过测试   |

| glStencilOp函数行为 | 描述                                                                     |     |
| ------------------- | ------------------------------------------------------------------------ | --- |
| GL_KEEP             | 保存当前储存的模板值                                                     |     |
| GL_ZERO             | 将模板值设置为0                                                          |     |
| GL_REPLACE          | 将模板值设置为glStencilFunc函数的**ref**值                               |     |
| GL_INCR             | 如果模板值小于最大值则将模板值加一                                       |     |
| GL_INCR_WRAP        | 如果模板值小于最大值则将模板值加一，但如果模板值超过了最大值则归零       |     |
| GL_DECT             | 如果模板值大于最小值则将模板值减一                                       |     |
| GL_DECR_WRAP        | 如果模板值大于最小值则将模板值减一 ，但如果模板值小于0则将其设置为最大值 |     |
| GL_INVERT           | 按**位**翻转当前的模板缓冲值                                                                        |     |
*默认情况下glStencilOp是设置为(GL_KEEP, GL_KEEP,  GL_KEEP)的，即不论任何测试的结果是如何，模板缓冲都会保留他的值。默认的行为不会更新模板缓冲，所以如果想写入模板缓冲的话，需要至少对其中一个选项设置不同的值*

- ###### 模板测试应用
	- 物体轮廓(Object Outlining)，为每一个物体在周围创建一个有色边框。步骤如下：
		- 在绘制（需要添加轮廓的）物体**之前**，将模板函数设置为GL_ALWAYS，每当物体的片段被渲染时，将模板缓冲更新为1
		- 渲染物体
		- **禁用**模板写入以及深度测试
		- 将每个物体缩放一点点
		- 使用一个不同的片段着色器，输出一个单独的边框颜色
		- 再次绘制物体，但是在他们片段的模板值不等于1的时候才绘制
		- 再次启用模板写入和深度测试

#### 混合(Blending)
- ###### Alpha Cut
	- 在片段着色器中直接舍弃alpha值低于阈值的片段
		- <mark>if (texture.a < 0.1) <br>&emsp;discard; </mark>
	- 贴图的上和下，左和右会进行插值，导致贴图的四周会出现边框无法被丢弃，可以通过把贴图环绕方式改为**GL_CLAMP_TO_EDGE**来解决
- ###### Alpha Blend
	- 可以将半透明物体和物体后面的物体的颜色进行混合来达到半透明的效果
	- 通过GL_BLEND开启
		- <mark>glEnable(GL_BLEND)</mark>
	- **OpenGL的混合方程**
		- ![[OpenGL_混合方程.png]]
			- <span style="color:green">C<sub>source</sub></span> ：源颜色向量，源自纹理的颜色向量，**离相机更近的颜色**
			- <span style="color:green">F<sub>source</sub></span> ：源因子值，指定了alpha值对源颜色的影响
			- <span style="color:red">C<sub>destination</sub></span> ：目标颜色向量，当前储存在颜色缓冲中的颜色向量，即**背景(已经渲染过的片段)/里相机更远的颜色**
			- <span style="color:red">F<sub>destination</sub></span> ：目标因子值，指定了alpha值对目标颜色的影响
			- *只有当片段着色器运行完成，且所有测试都通过之后，混合方程才会应用到片段颜色输出与当前颜色缓冲中的值上*
	- **例子**：
		- ![[OpenGL_混合例子.png]]
		- 要将绿色方块绘制到红色方块的上面 (绿块离相机更近，是**源**，红块里相机更远，是**目标**)，结果为：
		-  ![[OpenGL_混合计算过程.png]]
		- ![[OpenGL_混合例子结果.png]]
	- 可以通过glBlendFunc来设置源和目标因子
		- <mark>glBlendFunc(GLenum sfactor, GLenum dfactor)</mark>
			- sfactor：源因子
			- dfactor：目标因子
	- 也可以通过glBlendFuncSeparate来将颜色和alpha设置为不同的选项
		- <mark>glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)</mark>
	- 还可以通过glBlendEquation来改变方程中源和目标之间的运算符
		- <mark>glBlendEquation(GLenum mode)</mark>
			- GL_FUNC_ADD：默认选项，将两个分量相加，Src + Dst
			- GL_FUNC_SUBTRACT：将两个分量相减，Src - Dst
			- GL_FUNC_REVERSE_SUBTRACT：将两个分量调换顺序并相减：Dst - Src

| 混合因子选项                | 值                        |
| --------------------------- | ------------------------- |
| GL_ZERO                     | 因子等于**0**                 |
| GL_ONE                      | 因子等于**1**                 |
| GL_SRC_COLOR                | 因子等于**源颜色**向量        |
| GL_ONE_MINUS_SRC_COLOR      | 因子等于**1-源颜色**向量      |
| GL_DST_COLOR                | 因子等于**目标颜色**向量      |
| GL_ONE_MINUS_DST_COLOR      | 因子等于**1-目标颜色**向量    |
| GL_SRC_ALPHA                | 因子等于**源alpha**分量       |
| GL_ONE_MINUS_SRC_ALPHA      | 因子等于**1-源alpha**分量     |
| GL_DST_ALPHA                | 因子等于**目标alpha**分量     |
| GL_ONE_MINUS_DST_ALPHA      | 因子等于**1-目标alpha**分量   |
| GL_CONSTANT_COLOR           | 因子等于**常数**向量          |
| GL_ONE_MINUS_CONSTANT_COLOR | 因子等于**1-常数**向量        |
| GL_CONSTANT_ALPHA           | 因子等于**常数向量alpha**分量 |
| GL_MINUS_CONSTANT_ALPHA     | 因子等于**1-常数向量alpha**分量                          |

- ###### 渲染半透明物体与不透明物体的顺序问题
	- 当绘制一个由不透明和透明物体的场景时，大体的原则是：
		- 先绘制所有**不透明**物体
		- 对所有透明物体**排序**
		- **按顺序**绘制所有透明的物体(从远到近)
			- 排序代码：
			- ![[OpenGL_透明物体排序1.png]]
			- ![[OpenGL_透明物体排序2.png]]
- ###### 其他问题
	- 如果在渲染半透明物体之前开启了模板测试，需要在渲染半透明物体之前禁用模板测试写入

#### 面剔除(Face Culling)
- 面剔除用来剔除**无法被摄像机看到**的面 (不面向摄像机的面)，这样可以减少非常大的性能开销
- OpenGL通过分析顶点数据的**环绕顺序** (Winding Order)来确定哪些面是**正向面** (Front Face)， 哪些面是**背向面** (Back Face)
- ###### 环绕顺序
	- 环绕顺序用于帮助OpenGL定义三角形的哪个面是正面哪个面是背面
	- 每组组成三角形的三个顶点的**定义顺序**即为该三角形的环绕顺序
	- ![[OpenGL_三角形环绕顺序.png]]
	- 一个三角形只有两种环绕顺序，**顺时针**和**逆时针**
	- 默认情况下**逆时针**顺序定义的顶点将会被处理为**正向**三角形
	- ![[OpenGL_观察者视角三角形正反面.png]]
	- 当一个三角形的两个面都是逆时针顺序定义的时候，**朝外**的一面是**逆时针**，而**朝向物体内部**的一面则是在渲染时是**顺时针**顺序。可以理解为在一张纸上画一个镂空的图案，面向自己的一面的图案是逆时针的，而当把纸水平翻转过来的时候，面向自己的图案就变成了顺时针，这样就可以区分哪面是正面，哪面是背面
- ###### 面剔除
	- 面剔除默认也是禁用状态，可以通过GL_CULL_FACE来开启
		- <mark>glEnable(GL_CULL_FACE)</mark>
	- 可以通过glCullFace来设置要剔除的是正面还是背面，**默认值是GL_BACK**
		- <mark>glCullFace( GL_BACK)</mark>
	- 还可以通过glFrontFace来告诉OpenGL哪个环绕顺序的面是正向面，**默认是GL_CCW**
		- <mark>glFrontFace(GL_CCW)</mark>

| glCullFace 选项   | 描述         |
| ----------------- | ------------ |
| GL_BACK           | 只剔除背向面 |
| GL_FRONT          | 只剔除正向面 |
| GL_FRONT_AND_BACK | 剔除正向面和背向面             |

| glFrontFace 选项 | 描述                               |
| ---------------- | ---------------------------------- |
| GL_CCW           | 将逆时针顺序顶点定义的面设为正向面 |
| GL_CW            | 将顺时针顺序顶点定义的面设为正向面                                   |

