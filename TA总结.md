# TA知识点总结
#渲染流水线
```toc
```

## 渲染流水线

***CPU***
**应用阶段：** 
- 进行渲染设置
	- 开关**深度测试**，设置深度测试条件
	- 开关**模板测试**，配置模板测试
	- 开关**面剔除**
	- ...
- 准备场景数据
	- 场景里的**模型数据**：模型的位置、大小、朝向
	- 模型的**顶点数据**：每一个顶点的位置、法线方向、纹理贴图(UV)、顶点色、切线方向
	- 场景里的**光源数据**：灯光类型、位置、朝向、不同的灯光的特殊属性
	- 场景里的**摄像机数据**：摄像机的位置、朝向、其他属性
	- ... 
- Shader所需的全局参数
	- MVP矩阵
	- 贴图
	- 各种自定义参数
	- ...
- 将数据输出到几何阶段

***GPU***
**几何阶段：**
- 顶点着色器(可编程)
	- **将顶点模型顶点位置变换到裁剪空间**
	- 变换各种向量的所处的空间
	- 顶点动画
	- 向下一阶段的着色器传递各种自定义数据
- 曲面细分(可选)
	- 细分图元
- 几何着色器(可选)
	- 逐图元着色
	- 生成更多的图元
- 裁剪(可配置)
	- 任何超出NDC范围的图元都会被裁剪掉不会发送到下一个阶段
- 屏幕映射(不可配置、编程)
	- 把每个图元的顶点坐标从3D转换到2D的屏幕坐标系中

**光栅化阶段：**
- 三角形设置(不可配置、编程)
	- 拿到映射到2D空间的顶点位置并把他们组装成三角形
- 三角形遍历(不可配置、编程)
	- 找到当前三角形覆盖了屏幕上的哪些像素，被覆盖的区域会生成**片段**
	- 每个片段的属性，如位置、法线方向、切线方向、UV等，由他所属的三角形的三个顶点的对应属性插值得来
	- 片段着色器(可编程)
		- 片段着色器会通过一系列自定义的计算计算出当前片段最终的颜色
	- 逐片元操作(可配置)
		- 使用深度测试、模板测试等决定每个片段的可见性
		- 如果一个片段通过了所有测试，那么他会和在颜色缓冲中的颜色进行混合(如果开启了的话)，或者将颜色缓冲已有的相同位置的颜色替换掉


## 功能

#### 前向渲染(Forward Rendering) V.S. 延迟渲染(Defered Rendering)
待完工

#### 深度测试
待完工

#### 模板测试
待完工

#### 混合
待完工

#### 几何着色器
待完工

#### 帧缓冲
待完工


## 光照模型
看完PBR写

#### 法线贴图
待完工

#### 视差贴图
待完工



## 后处理

#### Gamma校正

#### 抗锯齿
待完工

#### HDR
待完工

#### 卷积核的概念
待完工

#### Bloom
待完工

#### 模糊/高斯模糊
待完工

#### 屏幕空间环境光遮蔽
待完工

#### 屏幕空间反射
LearnOpenGL没讲， 要查

## 其他的知识点

#### OpenGL 和 DirectX的区别
OpenGL的屏幕坐标系原点在**左下角**，最大值在右上角
DirectX的屏幕坐标系原点在**左上角**，最大值在右下角

#### 片段与像素的区别
像素是屏幕上最小的一个显示单位，它能够显示的颜色是由一个或者多个片段的颜色构成的。如果场景没有任何片段被遮挡住，那么可以说片段就等于像素。但是在实际的场景中，一个片段很可能会被在他前面的片段所遮挡住，被遮挡住的片段的就不会显示在他本来对应的像素中，这时候片段和像素就不相等了。如果场景中还有半透明的物体，那么一个像素的颜色还可以是多个片段的颜色的混合

#### 双重缓冲
在用户的屏幕上显示的颜色即为帧缓冲的颜色缓冲里的颜色，为了避免用户看到一个一个片段正在逐步渲染到屏幕上，GPU会使用双重缓冲。场景的渲染结果将会被写入到后置缓冲中，当整个场景都渲染完成，前后缓冲中的内容将会交换，使得一幅完整的画面能一次性显示在用户的屏幕上